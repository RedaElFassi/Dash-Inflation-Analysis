# -*- coding: utf-8 -*-
# =========================================================
# Dash Linkers ‚Äî Outright / Spread / Fly + Regression
# (NA-drop, lookback/reg-window clipp√©s & fl√©ch√©s, tenor
#  d√©duit du nom du linker, titres explicites)
# =========================================================
import re
import socket
import webbrowser
from typing import Optional, List, Tuple

import numpy as np
import pandas as pd

import dash
from dash import Dash, dcc, html, Input, Output, State, callback
import plotly.graph_objects as go
from dateutil.relativedelta import relativedelta

# =========================================================
# PR√âREQUIS dans ton scope Python :
#   Linker_lists: Dict[str, List[str]]
#   RY_dataframes, BE_dataframes, ZSPREAD_dataframes, Iota_dataframes:
#       Dict[str, pd.DataFrame] (index datetime, colonnes = security descriptions exactes)
#   data: pd.DataFrame avec colonnes "Country 2Y/3Y/5Y/7Y/10Y/15Y/20Y/25Y/30Y"
# =========================================================

# =========================
# CONFIG
# =========================
COUNTRIES = ["Italy", "France", "BTPItaly", "Spain", "Germany"]
TENORS = [2, 3, 5, 7, 10, 15, 20, 25, 30]
MONTHS_MAP = {
    "JAN":1,"FEB":2,"MAR":3,"APR":4,"MAY":5,"JUN":6,
    "JUL":7,"AUG":8,"SEP":9,"OCT":10,"NOV":11,"DEC":12
}

LOOKBACKS = {
    "1m": relativedelta(months=1),
    "2m": relativedelta(months=2),
    "3m": relativedelta(months=3),
    "6m": relativedelta(months=6),
    "1Y": relativedelta(years=1),
    "2Y": relativedelta(years=2),
    "3Y": relativedelta(years=3),
    "5Y": relativedelta(years=5),
    "10Y": relativedelta(years=10),
}

REG_WINDOWS = {
    "3M": relativedelta(months=3),
    "6M": relativedelta(months=6),
    "1Y": relativedelta(years=1),
    "2Y": relativedelta(years=2),
    "3Y": relativedelta(years=3),
}

# =========================
# HELPERS ‚Äî parsing tenor, s√©ries, lookbacks
# =========================
def _today() -> pd.Timestamp:
    # point d‚Äôancrage ‚Äúaujourd‚Äôhui‚Äù (index typique des df = dates de cl√¥ture)
    return pd.Timestamp.today().normalize()

def _years_between(a: pd.Timestamp, b: pd.Timestamp) -> float:
    return float((b - a).days) / 365.25

def infer_tenor_from_security_name(secname: str, asof: Optional[pd.Timestamp] = None) -> Optional[int]:
    """
    Essaie de d√©duire la maturit√© (en ann√©es) depuis le nom du linker :
      - formats pris en charge: '11/34', '11/2034', 'Nov-34', 'Nov 2034', 'NOV34', 'NOV 34', '2034'
      - pour un 'yy' ambigu, on mappe 00‚Äì79 -> 2000‚Äì2079, 80‚Äì99 -> 1980‚Äì1999 (convention raisonnable)
    On calcule (MaturityDate - today) en ann√©es, puis on choisit le TENOR le plus proche.
    """
    if not secname:
        return None
    s = secname.upper()
    asof = (asof or _today())

    # 1) mm/yy or mm/yyyy e.g. '11/34' '11/2034'
    m = re.search(r'\b(\d{1,2})\s*/\s*(\d{2,4})\b', s)
    if m:
        mm = int(m.group(1))
        yy = int(m.group(2))
        year = 2000 + yy if yy < 80 else (1900 + yy if yy < 100 else yy)
        month = min(max(mm, 1), 12)
        mat = pd.Timestamp(year=year, month=month, day=15)
        yrs = _years_between(asof, mat)
        return min(TENORS, key=lambda t: abs(t - yrs)) if yrs > 0 else min(TENORS, key=lambda t: abs(t - abs(yrs)))

    # 2) 'NOV 2034' / 'NOV-34' / 'NOV34'
    m = re.search(r'\b([A-Z]{3})[\s\-]*([0-9]{2,4})\b', s)
    if m and m.group(1) in MONTHS_MAP:
        month = MONTHS_MAP[m.group(1)]
        yy = int(m.group(2))
        year = 2000 + yy if yy < 80 else (1900 + yy if yy < 100 else yy)
        mat = pd.Timestamp(year=year, month=month, day=15)
        yrs = _years_between(asof, mat)
        return min(TENORS, key=lambda t: abs(t - yrs)) if yrs > 0 else min(TENORS, key=lambda t: abs(t - abs(yrs)))

    # 3) '2034' isol√©
    m = re.search(r'\b(19|20)\d{2}\b', s)
    if m:
        year = int(m.group(0))
        mat = pd.Timestamp(year=year, month=6, day=15)
        yrs = _years_between(asof, mat)
        return min(TENORS, key=lambda t: abs(t - yrs)) if yrs > 0 else min(TENORS, key=lambda t: abs(t - abs(yrs)))

    # 4) '34' isol√© (dangereux, on √©vite)
    return None

def get_metric_dataframe(metric: str, country: Optional[str]) -> Optional[pd.DataFrame]:
    if not country:
        return None
    if metric == "RY":
        return RY_dataframes.get(country)
    if metric == "BE":
        return BE_dataframes.get(country)
    if metric == "IOTA":
        return Iota_dataframes.get(country)
    if metric == "ZSPREAD":
        return ZSPREAD_dataframes.get(country)
    return None

def get_linker_series(metric: str, country: Optional[str], linker: Optional[str]) -> Optional[pd.Series]:
    df = get_metric_dataframe(metric, country)
    if df is None or not linker or linker not in df.columns:
        return None
    s = pd.to_numeric(df[linker], errors="coerce").dropna()
    s.name = f"{metric} | {country} | {linker}"
    return s

def align_inner(*series: Optional[pd.Series]) -> pd.DataFrame:
    """Concat strict (inner) des s√©ries non-nulles; colonnes s1,s2,s3 dans l‚Äôordre d‚Äôentr√©e. Drop NA."""
    cols, arr = [], []
    for i, s in enumerate(series, start=1):
        if isinstance(s, pd.Series) and not s.empty:
            cols.append(f"s{i}")
            arr.append(s.astype(float))
    if not arr:
        return pd.DataFrame()
    df = pd.concat(arr, axis=1, join="inner").dropna()
    df.columns = cols
    return df

def constructed_mode(c1, l1, c2, l2, c3, l3) -> str:
    filled = [bool(c1 and l1), bool(c2 and l2), bool(c3 and l3)]
    if filled[0] and filled[1] and not filled[2]:
        return "spread"
    if all(filled):
        return "fly"
    return "outright"

def constructed_formula(mode: str, l1: Optional[str], l2: Optional[str], l3: Optional[str]) -> str:
    if mode == "spread" and l1 and l2:
        return f"{l1} ‚àí {l2}"
    if mode == "fly" and l1 and l2 and l3:
        return f"2√ó{l2} ‚àí {l1} ‚àí {l3}"
    return f"{l1}" if l1 else "‚Äî"

def _clip_series_by_lookback(s: pd.Series, lookback_key: str) -> Tuple[pd.Series, str]:
    """
    Drop NA, puis clip √† la fen√™tre demand√©e. Retourne (subseries, note)
    La note pr√©cise si on a d√ª r√©duire (ex: demand√© 5Y, dispo 3.2Y).
    """
    s = s.dropna().sort_index()
    if s.empty:
        return s, "Empty series after NA drop."
    desired_delta = LOOKBACKS.get(lookback_key, relativedelta(years=10))
    end = s.index.max()
    start_req = end - desired_delta
    start_avail = s.index.min()
    # fen√™tre r√©ellement disponible
    start_final = max(start_req, start_avail)
    sub = s.loc[s.index >= start_final]

    # calcul des ann√©es
    desired_years = abs(_years_between(start_req, end))
    avail_years = abs(_years_between(start_avail, end))
    used_years = abs(_years_between(start_final, end))

    note = f"Requested ‚âà {desired_years:.1f}Y | Available ‚âà {avail_years:.1f}Y ‚Üí Using ‚âà {used_years:.1f}Y"
    return sub, note

def credit_spread_series(country: str, tenor: int) -> Optional[pd.Series]:
    """Spread (country ‚Äì Germany) au tenor donn√©."""
    col_c = f"{country} {tenor}Y"
    col_g = f"Germany {tenor}Y"
    if country == "Germany":
        return None
    if (col_c not in data.columns) or (col_g not in data.columns):
        return None
    s = pd.to_numeric(data[col_c], errors="coerce") - pd.to_numeric(data[col_g], errors="coerce")
    return s.dropna().rename(f"CS {country}-DE {tenor}Y")

def credit_spread_10y(country: str) -> Optional[pd.Series]:
    """CS10Y(country) = Ctry 10Y ‚àí DE 10Y. Germany ‚Üí 0 s√©rie si DE 10Y dispo."""
    col_g = "Germany 10Y"
    if col_g not in data.columns:
        return None
    if country == "Germany":
        base = pd.to_numeric(data[col_g], errors="coerce").dropna()
        return (base*0.0).rename("CS10Y Germany (0)")
    col_c = f"{country} 10Y"
    if col_c not in data.columns:
        return None
    s = pd.to_numeric(data[col_c], errors="coerce") - pd.to_numeric(data[col_g], errors="coerce")
    return s.dropna().rename(f"CS10Y {country}-DE")

def credit_spread_10y_diff(c1: str, c2: str) -> Optional[pd.Series]:
    """[CS10Y(C1) ‚àí CS10Y(C2)] = C1 10Y ‚àí C2 10Y."""
    col1, col2 = f"{c1} 10Y", f"{c2} 10Y"
    if col1 not in data.columns or col2 not in data.columns:
        return None
    s = pd.to_numeric(data[col1], errors="coerce") - pd.to_numeric(data[col2], errors="coerce")
    return s.dropna().rename(f"CS10Y diff ({c1}‚àí{c2})")

def scatter_with_fit(x: pd.Series, y: pd.Series, title: str, xlab: str, ylab: str) -> go.Figure:
    X = x.values.astype(float); Y = y.values.astype(float)
    mask = np.isfinite(X) & np.isfinite(Y)
    X = X[mask]; Y = Y[mask]
    fig = go.Figure()
    fig.update_layout(title=title, template="plotly_white",
                      legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1))
    fig.update_layout(xaxis_title=xlab, yaxis_title=ylab)
    if X.size < 2:
        return fig
    slope, intercept = np.polyfit(X, Y, 1)
    line_x = np.linspace(X.min(), X.max(), 200)
    line_y = slope * line_x + intercept
    fig.add_trace(go.Scatter(x=X, y=Y, mode="markers", name="Obs", opacity=0.75))
    fig.add_trace(go.Scatter(x=line_x, y=line_y, mode="lines", name=f"Fit y={slope:.3f}x+{intercept:.3f}",
                             line=dict(color="black")))
    return fig

# =========================
# APP
# =========================
app: Dash = dash.Dash(__name__, suppress_callback_exceptions=True)
app.title = "Dash Linkers ‚Äî Outright/Spreads/Flies"

def country_dropdown(id_, placeholder):
    return dcc.Dropdown(
        id=id_,
        options=[{"label": c, "value": c} for c in COUNTRIES],
        placeholder=placeholder, clearable=True
    )

def linker_dropdown(id_):
    return dcc.Dropdown(id=id_, options=[], placeholder="Choisis un linker", clearable=True)

app.layout = html.Div([
    html.H2("üìà Linkers Dashboard ‚Äî Outright, Spreads & Flies"),
    html.Div([
        html.Div([
            html.Label("Country 1"), country_dropdown("country1", "S√©lectionne Country 1"),
            html.Label("Linker 1"), linker_dropdown("linker1"),
        ], style={"display": "inline-block", "minWidth": 280, "marginRight": "16px"}),

        html.Div([
            html.Label("Country 2 (optionnel ‚Äî spread/fly)"), country_dropdown("country2", "S√©lectionne Country 2"),
            html.Label("Linker 2"), linker_dropdown("linker2"),
        ], style={"display": "inline-block", "minWidth": 280, "marginRight": "16px"}),

        html.Div([
            html.Label("Country 3 (optionnel ‚Äî fly)"), country_dropdown("country3", "S√©lectionne Country 3"),
            html.Label("Linker 3"), linker_dropdown("linker3"),
        ], style={"display": "inline-block", "minWidth": 280}),
    ], style={"marginBottom": "10px"}),

    html.Div([
        html.Label("Lookback"),
        dcc.RadioItems(
            id="lookback",
            options=[{"label": k, "value": k} for k in LOOKBACKS.keys()],
            value="1Y", inline=True
        ),
    ], style={"marginBottom": "8px"}),

    # Bloc r√©sum√© de la s√©rie construite + zone notes
    html.Div(id="constructed-summary", style={
        "background":"#f5f7fb","border":"1px solid #e6e9f2","padding":"8px 12px",
        "borderRadius":"8px","margin":"10px 0"
    }),
    html.Div(id="note-area", style={"color":"#555","fontSize":"12px","margin":"6px 0"}),

    dcc.Store(id="reg_tick", data=0),

    dcc.Tabs(id="section", value="RY", children=[
        dcc.Tab(label="Real Yield", value="RY"),
        dcc.Tab(label="Break-evens", value="BE"),
        dcc.Tab(label="Iotas", value="IOTA"),
        dcc.Tab(label="Regression", value="REG"),
    ]),

    html.Div(id="section-controls", style={"marginTop": "10px"}),

    dcc.Loading(html.Div(id="plots-area", style={"marginTop": "12px"}), type="default")
])

# =========================
# DROPDOWNS d√©pendants
# =========================
@callback(Output("linker1", "options"), Input("country1", "value"))
def update_linker1_options(country1):
    if country1 and country1 in Linker_lists:
        return [{"label": l, "value": l} for l in Linker_lists[country1]]
    return []

@callback(Output("linker2", "options"), Input("country2", "value"))
def update_linker2_options(country2):
    if country2 and country2 in Linker_lists:
        return [{"label": l, "value": l} for l in Linker_lists[country2]]
    return []

@callback(Output("linker3", "options"), Input("country3", "value"))
def update_linker3_options(country3):
    if country3 and country3 in Linker_lists:
        return [{"label": l, "value": l} for l in Linker_lists[country3]]
    return []

# =========================
# CONTROLES sp√©cifiques √† l‚Äôonglet
# =========================
@callback(Output("section-controls", "children"), Input("section", "value"))
def render_section_controls(section):
    if section == "REG":
        return html.Div([
            html.Label("Fen√™tre de r√©gression"),
            dcc.RadioItems(
                id="reg_window",
                options=[{"label": k, "value": k} for k in REG_WINDOWS.keys()],
                value="6M", inline=True
            ),
            html.Div([
                html.Div("R√®gles de la r√©gression :", style={"fontWeight": 600}),
                html.Ul([
                    html.Li("Outright : Iota(Linker1) ~ Credit spread tenor proche (Country1 ‚àí Germany)."),
                    html.Li("Spread (2 pays) : (Iota1 ‚àí Iota2) ~ [CS10Y(C1) ‚àí CS10Y(C2)]."),
                    html.Li("Fly (3 pays) : 2√óIota2 ‚àí Iota1 ‚àí Iota3 ~ CS10Y(Country2)."),
                ], style={"margin": "6px 0 0 18px"})
            ], style={"fontSize": 12, "opacity": 0.85, "marginTop": "6px"})
        ])
    return html.Div()

# Bloc r√©sum√© de la s√©rie construite (au-dessus des tabs)
@callback(
    Output("constructed-summary", "children"),
    Input("country1", "value"), Input("linker1", "value"),
    Input("country2", "value"), Input("linker2", "value"),
    Input("country3", "value"), Input("linker3", "value"),
    Input("section", "value")
)
def update_constructed_summary(c1, l1, c2, l2, c3, l3, section):
    mode = constructed_mode(c1, l1, c2, l2, c3, l3)
    formula = constructed_formula(mode, l1, l2, l3)
    title = dict(RY="Real Yield", BE="Break-evens", IOTA="Iotas", REG="Regression").get(section, "")
    return html.Div([
        html.Div("Constructed Series", style={"fontWeight":700, "marginBottom":"4px"}),
        html.Pre(formula, style={"margin":"0","whiteSpace":"pre-wrap","fontFamily":"monospace"}),
        html.Div(f"Mode: {mode.UPPER()}  |  Section: {title}", style={"fontSize":"12px","color":"#555","marginTop":"4px"})
    ])

# Petit "tick" pour rafra√Æchir la REG quand on change la fen√™tre
@callback(
    Output("reg_tick", "data"),
    Input("reg_window", "value"),
    State("reg_tick", "data"),
    prevent_initial_call=True
)
def bump_reg_tick(reg_val, tick):
    try:
        return int(tick or 0) + 1
    except Exception:
        return 1

# =========================
# NOTE AREA (lookback/reg-window messages)
# =========================
@callback(
    Output("note-area", "children"),
    Input("section", "value"),
    Input("lookback", "value"),
    Input("country1", "value"), Input("linker1", "value"),
    Input("country2", "value"), Input("linker2", "value"),
    Input("country3", "value"), Input("linker3", "value"),
    Input("reg_tick", "data"),
    State("reg_window", "value")
)
def update_note(section, lookback, c1, l1, c2, l2, c3, l3, _tick, reg_window):
    mode = constructed_mode(c1, l1, c2, l2, c3, l3)
    notes = []
    if section in ("RY","BE","IOTA"):
        # on va estimer la dispo de la s√©rie construite pour info
        metric = section
        s1 = get_linker_series(metric, c1, l1) if c1 and l1 else None
        s2 = get_linker_series(metric, c2, l2) if c2 and l2 else None
        s3 = get_linker_series(metric, c3, l3) if c3 and l3 else None
        if mode == "outright" and s1 is not None and not s1.dropna().empty:
            _, note = _clip_series_by_lookback(s1, lookback); notes.append(note)
        elif mode == "spread":
            df = align_inner(s1, s2)
            if not df.empty and df.shape[1] >= 2:
                _, note = _clip_series_by_lookback(df["s1"] - df["s2"], lookback); notes.append(note)
        elif mode == "fly":
            df = align_inner(s1, s2, s3)
            if not df.empty and df.shape[1] >= 3:
                _, note = _clip_series_by_lookback(2.0*df["s2"] - df["s1"] - df["s3"], lookback); notes.append(note)
    elif section == "REG":
        # message g√©n√©rique (la fen√™tre exacte est montr√©e dans le titre/reg plot)
        if reg_window in REG_WINDOWS:
            lab = reg_window
        else:
            lab = "6M"
        notes.append(f"Regression window requested: {lab} ‚Äî auto-clipped to common data availability.")
    return html.Ul([html.Li(n) for n in notes]) if notes else html.Div()

# =========================
# RENDU principal (plots)
# =========================
@callback(
    Output("plots-area", "children"),
    Input("section", "value"),
    Input("lookback", "value"),
    Input("country1", "value"),
    Input("country2", "value"),
    Input("country3", "value"),
    Input("linker1", "value"),
    Input("linker2", "value"),
    Input("linker3", "value"),
    Input("reg_tick", "data"),   # force refresh r√©gres quand fen√™tre change
    State("reg_window", "value"),
    prevent_initial_call=False
)
def render_plots(section, lookback, c1, c2, c3, l1, l2, l3, _tick, reg_window):
    mode = constructed_mode(c1, l1, c2, l2, c3, l3)

    # ===== Timeseries sections (RY/BE/IOTA) =====
    if section in ("RY", "BE", "IOTA"):
        metric = section
        s1 = get_linker_series(metric, c1, l1) if c1 and l1 else None
        s2 = get_linker_series(metric, c2, l2) if c2 and l2 else None
        s3 = get_linker_series(metric, c3, l3) if c3 and l3 else None

        if mode == "outright":
            if s1 is None or s1.dropna().empty:
                return html.Div("S√©lection incompl√®te ou donn√©es introuvables.", style={"color":"crimson"})
            series, _ = _clip_series_by_lookback(s1, lookback)
            title = f"{metric} ‚Äî {l1}"
            subtitle = f"Outright: {l1}"

        elif mode == "spread":
            df = align_inner(s1, s2)
            if df.empty or df.shape[1] < 2:
                return html.Div("Donn√©es insuffisantes pour le spread.", style={"color":"crimson"})
            series, _ = _clip_series_by_lookback(df["s1"] - df["s2"], lookback)
            title = f"{metric} ‚Äî {l1} ‚àí {l2}"
            subtitle = f"Spread: {l1} ‚àí {l2}"

        else:  # fly
            df = align_inner(s1, s2, s3)
            if df.empty or df.shape[1] < 3:
                return html.Div("Donn√©es insuffisantes pour le fly.", style={"color":"crimson"})
            series, _ = _clip_series_by_lookback(2.0*df["s2"] - df["s1"] - df["s3"], lookback)
            title = f"{metric} ‚Äî 2√ó{l2} ‚àí {l1} ‚àí {l3}"
            subtitle = f"Fly: 2√ó{l2} ‚àí {l1} ‚àí {l3}"

        fig = go.Figure()
        fig.add_trace(go.Scatter(x=series.index, y=series.values, mode="lines", name=subtitle))
        fig.update_layout(
            title=title,
            xaxis_title="Date",
            yaxis_title=metric,
            template="plotly_white",
            hovermode="x unified",
            legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1)
        )
        return dcc.Graph(figure=fig)

    # ===== Regression section =====
    if section == "REG":
        win = REG_WINDOWS.get(reg_window or "6M", REG_WINDOWS["6M"])

        def regress_and_plot(x_raw: pd.Series, y_raw: pd.Series, title_prefix: str, xlab: str, ylab: str):
            # drop NA + align + clip fen√™tre demand√©e (sur l'intersection)
            x = x_raw.dropna(); y = y_raw.dropna()
            join = pd.concat([x.rename("x"), y.rename("y")], axis=1, join="inner").dropna().sort_index()
            if join.empty:
                return html.Div("Pas assez d‚Äôobservations communes pour la r√©gression.", style={"color": "crimson"})

            end = join.index.max()
            start_req = end - win
            start_avail = join.index.min()
            start_final = max(start_req, start_avail)
            sub = join.loc[join.index >= start_final]
            if len(sub) < 3:
                return html.Div("Fen√™tre trop courte apr√®s alignement.", style={"color": "crimson"})

            # message de clipping dans le titre
            desired_years = abs(_years_between(start_req, end))
            avail_years = abs(_years_between(start_avail, end))
            used_years = abs(_years_between(start_final, end))
            title = f"{title_prefix} ‚Äî requested‚âà{desired_years:.1f}Y | available‚âà{avail_years:.1f}Y ‚Üí using‚âà{used_years:.1f}Y"

            fig = scatter_with_fit(sub["x"], sub["y"], title, xlab, ylab)

            X = sub["x"].values; Y = sub["y"].values
            mask = np.isfinite(X) & np.isfinite(Y)
            stats = html.Div()
            if mask.sum() >= 2:
                slope, intercept = np.polyfit(X[mask], Y[mask], 1)
                corr = np.corrcoef(X[mask], Y[mask])[0,1]
                stats = html.Div([
                    html.Div(f"Observations: {int(mask.sum())}"),
                    html.Div(f"Slope (beta): {slope:.3f}"),
                    html.Div(f"Intercept: {intercept:.3f}"),
                    html.Div(f"Corr: {corr:.3f}"),
                ], style={"marginTop":"8px","fontSize":13,"opacity":0.85})
            return html.Div([dcc.Graph(figure=fig), stats])

        if mode == "outright":
            if not (c1 and l1):
                return html.Div("Choisis au minimum Country 1 et Linker 1.", style={"color": "crimson"})
            if c1 == "Germany":
                return html.Div("Pas de r√©gression outright pour Germany (pas de spread vs Germany).", style={"color":"crimson"})
            iota1 = get_linker_series("IOTA", c1, l1)
            if iota1 is None or iota1.dropna().empty:
                return html.Div("Iota introuvable pour ce linker.", style={"color":"crimson"})
            tenor = infer_tenor_from_security_name(l1, asof=_today())
            if tenor is None:
                return html.Div("Impossible d‚Äôinf√©rer le tenor depuis le nom du linker.", style={"color":"crimson"})
            cs = credit_spread_series(c1, tenor)
            if cs is None or cs.dropna().empty:
                return html.Div("S√©rie de credit spread indisponible.", style={"color":"crimson"})
            title_prefix = f"REG (OUTRIGHT) ‚Äî Iota({l1})  ~  CS {c1}-DE ({tenor}Y)"
            return regress_and_plot(cs, iota1, title_prefix, xlab=f"CS {c1}-DE ({tenor}Y)", ylab=f"Iota({l1})")

        if mode == "spread":
            i1 = get_linker_series("IOTA", c1, l1)
            i2 = get_linker_series("IOTA", c2, l2)
            df = align_inner(i1, i2)
            if df.empty or df.shape[1] < 2:
                return html.Div("Iotas introuvables / pas d‚Äôoverlap pour le spread.", style={"color":"crimson"})
            box = (df["s1"] - df["s2"]).rename(f"IotaBox({l1}‚àí{l2})")
            cs_diff = credit_spread_10y_diff(c1, c2)
            if cs_diff is None or cs_diff.dropna().empty:
                return html.Div("Credit spread 10Y diff√©rentiel indisponible.", style={"color":"crimson"})
            title_prefix = f"REG (SPREAD) ‚Äî IotaBox({l1} ‚àí {l2})  ~  CS10Y({c1}) ‚àí CS10Y({c2})"
            return regress_and_plot(cs_diff, box, title_prefix, xlab=f"CS10Y diff ({c1} ‚àí {c2})", ylab=f"IotaBox({l1}‚àí{l2})")

        # fly
        i1 = get_linker_series("IOTA", c1, l1)
        i2 = get_linker_series("IOTA", c2, l2)
        i3 = get_linker_series("IOTA", c3, l3)
        df = align_inner(i1, i2, i3)
        if df.empty or df.shape[1] < 3:
            return html.Div("Iotas introuvables / pas d‚Äôoverlap pour le fly.", style={"color":"crimson"})
        fly = (2.0*df["s2"] - df["s1"] - df["s3"]).rename(f"IotaFly(2√ó{l2}‚àí{l1}‚àí{l3})")
        cs_c2 = credit_spread_10y(c2)
        if cs_c2 is None or cs_c2.dropna().empty:
            return html.Div("Credit spread 10Y (Country2) indisponible.", style={"color":"crimson"})
        title_prefix = f"REG (FLY) ‚Äî IotaFly(2√ó{l2} ‚àí {l1} ‚àí {l3})  ~  CS10Y({c2})"
        return regress_and_plot(cs_c2, fly, title_prefix, xlab=f"CS10Y {c2}-DE", ylab=f"IotaFly(2√ó{l2}‚àí{l1}‚àí{l3})")

    return html.Div()

# =========================
# MAIN ‚Äî lancement
# =========================
def _get_local_ip() -> str:
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    try:
        s.connect(("8.8.8.8", 80))
        ip = s.getsockname()[0]
    except Exception:
        ip = "127.0.0.1"
    finally:
        s.close()
    return ip

if __name__ == "__main__":
    host, port = "0.0.0.0", 8057
    local_ip = _get_local_ip()
    print("\n================= SHARE THIS =================")
    print(f"Local (toi)    : http://localhost:{port}")
    print(f"R√©seau (√©quipe): http://{local_ip}:{port}")
    print("================================================\n")
    try:
        webbrowser.open(f"http://localhost:{port}")
    except Exception:
        pass
    app.run_server(host=host, port=port, debug=False)
