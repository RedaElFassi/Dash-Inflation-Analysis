# -*- coding: utf-8 -*-
# =========================================================
# Dash Linkers â€” Outright / Spread / Fly + Regression
# (version patchÃ©e avec Constructed Series, updates fixes,
# rÃ©gressions robustes et titres explicites)
# =========================================================
import re
import socket
import webbrowser
from typing import Optional, List

import numpy as np
import pandas as pd

import dash
from dash import Dash, dcc, html, Input, Output, State, callback
import plotly.graph_objects as go
from dateutil.relativedelta import relativedelta

# =========================================================
# PRÃ‰REQUIS â€” ces objets doivent exister dans le scope Python
#   Linker_lists: Dict[str, List[str]]
#   NOM_Eq_lists: Dict[str, List[str]]  # alignÃ© 1:1 avec Linker_lists[country]
#   RY_dataframes, BE_dataframes, ZSPREAD_dataframes, Iota_dataframes:
#       Dict[str, pd.DataFrame] (index=dates, colonnes=noms exacts de linkers)
#   data: pd.DataFrame avec colonnes "Country 2Y/3Y/5Y/7Y/10Y/15Y/20Y/25Y/30Y"
# =========================================================

# =========================
# CONFIG
# =========================
COUNTRIES = ["Italy", "France", "BTPItaly", "Spain", "Germany"]
TENORS = [2, 3, 5, 7, 10, 15, 20, 25, 30]

LOOKBACKS = {
    "1m": relativedelta(months=1),
    "2m": relativedelta(months=2),
    "3m": relativedelta(months=3),
    "6m": relativedelta(months=6),
    "1Y": relativedelta(years=1),
    "2Y": relativedelta(years=2),
    "3Y": relativedelta(years=3),
    "5Y": relativedelta(years=5),
    "10Y": relativedelta(years=10),
}

REG_WINDOWS = {
    "3M": relativedelta(months=3),
    "6M": relativedelta(months=6),
    "1Y": relativedelta(years=1),
    "2Y": relativedelta(years=2),
    "3Y": relativedelta(years=3),
}

# =========================
# HELPERS â€” sÃ©ries & math
# =========================
def nearest_tenor_from_nominal_equiv(nominal_equiv: Optional[str]) -> Optional[int]:
    """
    Extrait '(\d+)Y' d'une chaÃ®ne et renvoie le tenor disponible le plus proche.
    """
    if not nominal_equiv:
        return None
    m = re.search(r'(\d+)\s*[Yy]\b', str(nominal_equiv))
    if not m:
        return None
    val = int(m.group(1))
    return min(TENORS, key=lambda t: abs(t - val))

def get_metric_dataframe(metric: str, country: Optional[str]) -> Optional[pd.DataFrame]:
    if not country:
        return None
    if metric == "RY":
        return RY_dataframes.get(country)
    if metric == "BE":
        return BE_dataframes.get(country)
    if metric == "IOTA":
        return Iota_dataframes.get(country)
    if metric == "ZSPREAD":
        return ZSPREAD_dataframes.get(country)
    return None

def get_linker_series(metric: str, country: Optional[str], linker: Optional[str]) -> Optional[pd.Series]:
    df = get_metric_dataframe(metric, country)
    if df is None or not linker or linker not in df.columns:
        return None
    s = pd.to_numeric(df[linker], errors="coerce")
    s.name = f"{metric} | {country} | {linker}"
    return s

def slice_lookback(series: pd.Series, lookback_key: str) -> pd.Series:
    if series is None or series.empty:
        return pd.Series(dtype=float)
    end = series.dropna().index.max()
    if pd.isna(end):
        return pd.Series(dtype=float)
    start = end - LOOKBACKS.get(lookback_key, relativedelta(years=10))
    return series.loc[series.index >= start]

def credit_spread_series(country: str, tenor: int) -> Optional[pd.Series]:
    """Spread (country â€“ Germany) au tenor donnÃ©."""
    col_c = f"{country} {tenor}Y"
    col_g = f"Germany {tenor}Y"
    if country == "Germany":
        return None
    if (col_c not in data.columns) or (col_g not in data.columns):
        return None
    s = pd.to_numeric(data[col_c], errors="coerce") - pd.to_numeric(data[col_g], errors="coerce")
    s.name = f"CS {country} vs Germany ({tenor}Y)"
    return s

def credit_spread_10y(country: str) -> Optional[pd.Series]:
    """CS10Y(country) = country 10Y âˆ’ Germany 10Y. Pour Germany â†’ sÃ©rie nulle."""
    col_g = "Germany 10Y"
    if col_g not in data.columns:
        return None
    if country == "Germany":
        base = pd.to_numeric(data[col_g], errors="coerce")
        s = base * 0.0
        s.name = "CS10Y Germany (0)"
        return s
    col_c = f"{country} 10Y"
    if col_c not in data.columns:
        return None
    s = pd.to_numeric(data[col_c], errors="coerce") - pd.to_numeric(data[col_g], errors="coerce")
    s.name = f"CS10Y {country}-Germany"
    return s

def credit_spread_10y_diff(c1: str, c2: str) -> Optional[pd.Series]:
    """[CS10Y(C1) âˆ’ CS10Y(C2)] = C1 10Y âˆ’ C2 10Y."""
    col1, col2 = f"{c1} 10Y", f"{c2} 10Y"
    if col1 not in data.columns or col2 not in data.columns:
        return None
    s = pd.to_numeric(data[col1], errors="coerce") - pd.to_numeric(data[col2], errors="coerce")
    s.name = f"CS10Y diff ({c1} âˆ’ {c2})"
    return s

def scatter_with_fit(x: pd.Series, y: pd.Series, title: str, xlab: str, ylab: str) -> go.Figure:
    X = x.values.astype(float)
    Y = y.values.astype(float)
    mask = np.isfinite(X) & np.isfinite(Y)
    X = X[mask]; Y = Y[mask]
    fig = go.Figure()
    fig.update_layout(title=title, template="plotly_white",
                      legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1))
    if X.size < 2:
        fig.update_layout(xaxis_title=xlab, yaxis_title=ylab)
        return fig
    slope, intercept = np.polyfit(X, Y, 1)
    line_x = np.linspace(X.min(), X.max(), 200)
    line_y = slope * line_x + intercept
    fig.add_trace(go.Scatter(x=X, y=Y, mode="markers", name="Obs", opacity=0.75))
    fig.add_trace(go.Scatter(x=line_x, y=line_y, mode="lines", name=f"Fit y={slope:.3f}x+{intercept:.3f}",
                             line=dict(color="black")))
    fig.update_layout(xaxis_title=xlab, yaxis_title=ylab)
    return fig

# ---------- Helpers (nouveaux) : mode/format & alignement robuste ----------
def constructed_mode(c1, l1, c2, l2, c3, l3) -> str:
    filled = [bool(c1 and l1), bool(c2 and l2), bool(c3 and l3)]
    if filled[0] and filled[1] and not filled[2]:
        return "spread"
    if all(filled):
        return "fly"
    return "outright"

def constructed_formula(mode: str, l1: Optional[str], l2: Optional[str], l3: Optional[str]) -> str:
    if mode == "spread" and l1 and l2:
        return f"{l1} âˆ’ {l2}"
    if mode == "fly" and l1 and l2 and l3:
        return f"2Ã—{l2} âˆ’ {l1} âˆ’ {l3}"
    return f"{l1}" if l1 else "â€”"

def align_inner(*series: Optional[pd.Series]) -> pd.DataFrame:
    """Concat strict (inner) des sÃ©ries non-nulles; colonnes s1,s2,s3 dans lâ€™ordre dâ€™entrÃ©e."""
    cols, arr = [], []
    for i, s in enumerate(series, start=1):
        if isinstance(s, pd.Series) and not s.empty:
            cols.append(f"s{i}")
            arr.append(s.astype(float))
    if not arr:
        return pd.DataFrame()
    df = pd.concat(arr, axis=1, join="inner")
    df.columns = cols
    return df.dropna()

# =========================
# APP
# =========================
app: Dash = dash.Dash(__name__, suppress_callback_exceptions=True)
app.title = "Dash Linkers â€” Outright/Spreads/Flies"

def country_dropdown(id_, placeholder):
    return dcc.Dropdown(
        id=id_,
        options=[{"label": c, "value": c} for c in COUNTRIES],
        placeholder=placeholder, clearable=True
    )

def linker_dropdown(id_):
    return dcc.Dropdown(id=id_, options=[], placeholder="Choisis un linker", clearable=True)

app.layout = html.Div([
    html.H2("ðŸ“ˆ Linkers Dashboard â€” Outright, Spreads & Flies"),
    html.Div([
        html.Div([
            html.Label("Country 1"), country_dropdown("country1", "SÃ©lectionne Country 1"),
            html.Label("Linker 1"), linker_dropdown("linker1"),
        ], style={"display": "inline-block", "minWidth": 280, "marginRight": "16px"}),

        html.Div([
            html.Label("Country 2 (optionnel â€” spread/fly)"), country_dropdown("country2", "SÃ©lectionne Country 2"),
            html.Label("Linker 2"), linker_dropdown("linker2"),
        ], style={"display": "inline-block", "minWidth": 280, "marginRight": "16px"}),

        html.Div([
            html.Label("Country 3 (optionnel â€” fly)"), country_dropdown("country3", "SÃ©lectionne Country 3"),
            html.Label("Linker 3"), linker_dropdown("linker3"),
        ], style={"display": "inline-block", "minWidth": 280}),
    ], style={"marginBottom": "10px"}),

    html.Div([
        html.Label("Lookback"),
        dcc.RadioItems(
            id="lookback",
            options=[{"label": k, "value": k} for k in LOOKBACKS.keys()],
            value="1Y", inline=True
        ),
    ], style={"marginBottom": "8px"}),

    # Bloc rÃ©sumÃ© de la sÃ©rie construite
    html.Div(id="constructed-summary", style={
        "background":"#f5f7fb","border":"1px solid #e6e9f2","padding":"8px 12px",
        "borderRadius":"8px","margin":"10px 0"
    }),
    dcc.Store(id="reg_tick", data=0),

    dcc.Tabs(id="section", value="RY", children=[
        dcc.Tab(label="Real Yield", value="RY"),
        dcc.Tab(label="Break-evens", value="BE"),
        dcc.Tab(label="Iotas", value="IOTA"),
        dcc.Tab(label="Regression", value="REG"),
    ]),

    html.Div(id="section-controls", style={"marginTop": "10px"}),

    dcc.Loading(html.Div(id="plots-area", style={"marginTop": "12px"}), type="default")
])

# =========================
# DROPDOWNS dÃ©pendants
# =========================
@callback(Output("linker1", "options"), Input("country1", "value"))
def update_linker1_options(country1):
    if country1 and country1 in Linker_lists:
        return [{"label": l, "value": l} for l in Linker_lists[country1]]
    return []

@callback(Output("linker2", "options"), Input("country2", "value"))
def update_linker2_options(country2):
    if country2 and country2 in Linker_lists:
        return [{"label": l, "value": l} for l in Linker_lists[country2]]
    return []

@callback(Output("linker3", "options"), Input("country3", "value"))
def update_linker3_options(country3):
    if country3 and country3 in Linker_lists:
        return [{"label": l, "value": l} for l in Linker_lists[country3]]
    return []

# =========================
# CONTROLES spÃ©cifiques Ã  lâ€™onglet
# =========================
@callback(Output("section-controls", "children"), Input("section", "value"))
def render_section_controls(section):
    if section == "REG":
        return html.Div([
            html.Label("FenÃªtre de rÃ©gression"),
            dcc.RadioItems(
                id="reg_window",
                options=[{"label": k, "value": k} for k in REG_WINDOWS.keys()],
                value="6M", inline=True
            ),
            html.Div([
                html.Div("RÃ¨gles de la rÃ©gression :", style={"fontWeight": 600}),
                html.Ul([
                    html.Li("Outright : Iota(Linker1) ~ Credit spread tenor proche (Country1 âˆ’ Germany)."),
                    html.Li("Spread (2 pays) : (Iota1 âˆ’ Iota2) ~ [CS10Y(C1) âˆ’ CS10Y(C2)]."),
                    html.Li("Fly (3 pays) : 2Ã—Iota2 âˆ’ Iota1 âˆ’ Iota3 ~ CS10Y(Country2)."),
                ], style={"margin": "6px 0 0 18px"})
            ], style={"fontSize": 12, "opacity": 0.85, "marginTop": "6px"})
        ])
    return html.Div()

# Bloc rÃ©sumÃ© de la sÃ©rie construite (au-dessus des tabs)
@callback(
    Output("constructed-summary", "children"),
    Input("country1", "value"), Input("linker1", "value"),
    Input("country2", "value"), Input("linker2", "value"),
    Input("country3", "value"), Input("linker3", "value"),
    Input("section", "value")
)
def update_constructed_summary(c1, l1, c2, l2, c3, l3, section):
    mode = constructed_mode(c1, l1, c2, l2, c3, l3)
    formula = constructed_formula(mode, l1, l2, l3)
    title = dict(RY="Real Yield", BE="Break-evens", IOTA="Iotas", REG="Regression").get(section, "")
    return html.Div([
        html.Div("Constructed Series", style={"fontWeight":700, "marginBottom":"4px"}),
        html.Pre(formula, style={"margin":"0","whiteSpace":"pre-wrap","fontFamily":"monospace"}),
        html.Div(f"Mode: {mode.upper()}  |  Section: {title}", style={"fontSize":"12px","color":"#555","marginTop":"4px"})
    ])

# Petit "tick" pour rafraÃ®chir la REG quand on change la fenÃªtre
@callback(
    Output("reg_tick", "data"),
    Input("reg_window", "value"),
    State("reg_tick", "data"),
    prevent_initial_call=True
)
def bump_reg_tick(reg_val, tick):
    try:
        return int(tick or 0) + 1
    except Exception:
        return 1

# =========================
# RENDU principal (plots)
# =========================
@callback(
    Output("plots-area", "children"),
    Input("section", "value"),
    Input("lookback", "value"),
    Input("country1", "value"),
    Input("country2", "value"),
    Input("country3", "value"),
    Input("linker1", "value"),
    Input("linker2", "value"),
    Input("linker3", "value"),
    Input("reg_tick", "data"),   # force refresh rÃ©gres quand fenÃªtre change
    State("reg_window", "value"),
    prevent_initial_call=False
)
def render_plots(section, lookback, c1, c2, c3, l1, l2, l3, _tick, reg_window):
    mode = constructed_mode(c1, l1, c2, l2, c3, l3)

    # ===== Timeseries sections (RY/BE/IOTA) =====
    if section in ("RY", "BE", "IOTA"):
        metric = section
        s1 = get_linker_series(metric, c1, l1) if c1 and l1 else None
        s2 = get_linker_series(metric, c2, l2) if c2 and l2 else None
        s3 = get_linker_series(metric, c3, l3) if c3 and l3 else None

        if mode == "outright":
            if s1 is None or s1.empty:
                return html.Div("SÃ©lection incomplÃ¨te ou donnÃ©es introuvables.", style={"color":"crimson"})
            combined = slice_lookback(s1, lookback)
            title = f"{metric} â€” {l1}"
            subtitle = f"Outright: {l1}"
        elif mode == "spread":
            df = align_inner(s1, s2)
            if df.empty or df.shape[1] < 2:
                return html.Div("DonnÃ©es insuffisantes pour le spread.", style={"color":"crimson"})
            combined = slice_lookback(df["s1"] - df["s2"], lookback)
            title = f"{metric} â€” {l1} âˆ’ {l2}"
            subtitle = f"Spread: {l1} âˆ’ {l2}"
        else:  # fly
            df = align_inner(s1, s2, s3)
            if df.empty or df.shape[1] < 3:
                return html.Div("DonnÃ©es insuffisantes pour le fly.", style={"color":"crimson"})
            combined = slice_lookback(2.0*df["s2"] - df["s1"] - df["s3"], lookback)
            title = f"{metric} â€” 2Ã—{l2} âˆ’ {l1} âˆ’ {l3}"
            subtitle = f"Fly: 2Ã—{l2} âˆ’ {l1} âˆ’ {l3}"

        fig = go.Figure()
        fig.add_trace(go.Scatter(x=combined.index, y=combined.values, mode="lines", name=subtitle))
        fig.update_layout(
            title=title,
            xaxis_title="Date",
            yaxis_title=metric,
            template="plotly_white",
            hovermode="x unified",
            legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1)
        )
        return dcc.Graph(figure=fig)

    # ===== Regression section =====
    if section == "REG":
        win = REG_WINDOWS.get(reg_window or "6M", REG_WINDOWS["6M"])

        def regress_and_plot(x: pd.Series, y: pd.Series, title: str, xlab: str, ylab: str):
            join = pd.concat([x.rename("x"), y.rename("y")], axis=1, join="inner").dropna()
            if join.empty:
                return html.Div("Pas assez dâ€™observations communes pour la rÃ©gression.", style={"color": "crimson"})
            end = join.index.max()
            start = end - win
            sub = join.loc[join.index >= start]
            if len(sub) < 3:
                return html.Div("FenÃªtre trop courte aprÃ¨s alignement.", style={"color": "crimson"})
            fig = scatter_with_fit(sub["x"], sub["y"], title, xlab, ylab)
            X = sub["x"].values; Y = sub["y"].values
            mask = np.isfinite(X) & np.isfinite(Y)
            stats = html.Div()
            if mask.sum() >= 2:
                slope, intercept = np.polyfit(X[mask], Y[mask], 1)
                corr = np.corrcoef(X[mask], Y[mask])[0,1]
                stats = html.Div([
                    html.Div(f"Observations: {int(mask.sum())}"),
                    html.Div(f"Slope (beta): {slope:.3f}"),
                    html.Div(f"Intercept: {intercept:.3f}"),
                    html.Div(f"Corr: {corr:.3f}"),
                ], style={"marginTop":"8px","fontSize":13,"opacity":0.85})
            return html.Div([dcc.Graph(figure=fig), stats])

        if mode == "outright":
            if not (c1 and l1):
                return html.Div("Choisis au minimum Country 1 et Linker 1.", style={"color": "crimson"})
            iota1 = get_linker_series("IOTA", c1, l1)
            if iota1 is None or iota1.empty:
                return html.Div("Iota introuvable pour ce linker.", style={"color":"crimson"})
            if c1 == "Germany":
                return html.Div("Pas de rÃ©gression outright pour Germany (pas de spread vs Germany).", style={"color":"crimson"})
            tenor = None
            try:
                linkers = Linker_lists.get(c1, [])
                noms = NOM_Eq_lists.get(c1, [])
                idx = linkers.index(l1)
                tenor = nearest_tenor_from_nominal_equiv(noms[idx] if idx < len(noms) else None)
            except Exception:
                tenor = None
            if tenor is None:
                return html.Div("Impossible dâ€™infÃ©rer le tenor depuis le nominal Ã©quivalent.", style={"color":"crimson"})
            cs = credit_spread_series(c1, tenor)
            if cs is None or cs.empty:
                return html.Div("SÃ©rie de credit spread indisponible.", style={"color":"crimson"})
            title = f"REG (OUTRIGHT)  â€”  Iota({l1})  ~  CS {c1}-DE ({tenor}Y) â€” last {reg_window or '6M'}"
            return regress_and_plot(cs, iota1, title, xlab=f"CS {c1}-DE ({tenor}Y)", ylab=f"Iota({l1})")

        if mode == "spread":
            i1 = get_linker_series("IOTA", c1, l1)
            i2 = get_linker_series("IOTA", c2, l2)
            df = align_inner(i1, i2)
            if df.empty or df.shape[1] < 2:
                return html.Div("Iotas introuvables / pas dâ€™overlap pour le spread.", style={"color":"crimson"})
            box = df["s1"] - df["s2"]
            cs_diff = credit_spread_10y_diff(c1, c2)
            if cs_diff is None or cs_diff.empty:
                return html.Div("Credit spread 10Y diffÃ©rentiel indisponible.", style={"color":"crimson"})
            title = f"REG (SPREAD)  â€”  IotaBox({l1} âˆ’ {l2})  ~  CS10Y({c1}) âˆ’ CS10Y({c2}) â€” last {reg_window or '6M'}"
            return regress_and_plot(cs_diff, box, title, xlab=f"CS10Y diff ({c1} âˆ’ {c2})", ylab=f"IotaBox({l1}âˆ’{l2})")

        # fly
        i1 = get_linker_series("IOTA", c1, l1)
        i2 = get_linker_series("IOTA", c2, l2)
        i3 = get_linker_series("IOTA", c3, l3)
        df = align_inner(i1, i2, i3)
        if df.empty or df.shape[1] < 3:
            return html.Div("Iotas introuvables / pas dâ€™overlap pour le fly.", style={"color":"crimson"})
        fly = 2.0*df["s2"] - df["s1"] - df["s3"]
        cs_c2 = credit_spread_10y(c2)
        if cs_c2 is None or cs_c2.empty:
            return html.Div("Credit spread 10Y (Country2) indisponible.", style={"color":"crimson"})
        title = f"REG (FLY)  â€”  IotaFly(2Ã—{l2} âˆ’ {l1} âˆ’ {l3})  ~  CS10Y({c2}) â€” last {reg_window or '6M'}"
        return regress_and_plot(cs_c2, fly, title, xlab=f"CS10Y {c2}-DE", ylab=f"IotaFly(2Ã—{l2}âˆ’{l1}âˆ’{l3})")

    return html.Div()

# =========================
# MAIN â€” lancement (style â€œinspirÃ©â€)
# =========================
def _get_local_ip() -> str:
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    try:
        s.connect(("8.8.8.8", 80))
        ip = s.getsockname()[0]
    except Exception:
        ip = "127.0.0.1"
    finally:
        s.close()
    return ip

if __name__ == "__main__":
    host, port = "0.0.0.0", 8057  # tu peux changer le port
    local_ip = _get_local_ip()
    print("\n================= SHARE THIS =================")
    print(f"Local (toi)    : http://localhost:{port}")
    print(f"RÃ©seau (Ã©quipe): http://{local_ip}:{port}")
    print("================================================\n")
    try:
        webbrowser.open(f"http://localhost:{port}")
    except Exception:
        pass
    app.run_server(host=host, port=port, debug=False)
